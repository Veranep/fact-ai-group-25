from tracemalloc import start
import pandas as pd
import numpy as np
import random

# Updates the traveltimes file generated by generate_paths_and_traveltimes.py such that the file passes traveltime_test.py.
# Ultimatly, this script can be integrated into generate_paths_and_traveltimes, but for now it's a separate script.

routes = pd.read_csv('out_Brooklyn/zone_path.csv', header=None).values
travel_times = pd.read_csv('out_Brooklyn/zone_traveltime.csv', header=None).values

# number of noes
N = travel_times.shape[0]

tt_new = np.zeros((N, N), dtype=np.int64)

def get_route(start_id, dest_id):
    route = [start_id]

    while route[-1] != dest_id:
        # append the next node on this route
        route.append(routes[route[-1]][dest_id])

    return route

def get_traveltime(start_id, dest_id, time_array):
    return time_array[start_id, dest_id]

def compute_traveltime(route, time_array):
    travel_time = 0
    
    for i in range(1, len(route)):
        edge_tt = get_traveltime(route[i-1], route[i], time_array)
        travel_time += edge_tt

    return travel_time

def get_neighbours(node_id):
    # returns all nodes m for which route(node_id,m)==m, i.e. all nodes m that have one
    # edge from node_id to m.
    neighbours = []

    for m in range(N):
        if routes[node_id, m] == m:
            neighbours.append(m)

    return neighbours


# substitute the pairs (n,m) to all neighbours m by the traveltimes, after rounding to the nearest int
for node_id in range(N):
    nbs = get_neighbours(node_id)
    tt_new[node_id, nbs] = np.rint(travel_times[node_id, nbs])


for start_id in range(N):
    for dest_id in range(N):
        route = get_route(start_id, dest_id)

        tt_new[start_id, dest_id] = compute_traveltime(route, tt_new)


print('DONE')
np.savetxt('out_Brooklyn/zone_traveltime_new.csv', tt_new, fmt='%1.1f', delimiter=',')

